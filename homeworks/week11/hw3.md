## 請說明雜湊跟加密的差別在哪裡，為什麼密碼要雜湊過後才存入資料庫

加密（Encryption）

　　在密碼學中，加密是將明文資訊改變為難以讀取的密文內容，使之不可讀的過程。只有擁有解密方法的物件，經由解密過程，才能將密文還原為正常可讀的內容。



加密演算法可以分為「對稱式加密」與「非對稱式加密」：

　　對稱式加密（Symmetric Encryption），加密和解密使用的金鑰是相同的，金鑰長度太短的話，很容易被破解，對稱加密的運算速度比公鑰加密快。

　　非對稱式加密（Asymmetric Encryption），需要兩個金鑰：公開金鑰（Public key）、私密金鑰（Private key），公鑰可以自由發布，私鑰則由使用者秘密保存，通常使用公鑰加密，使用私鑰解密。



雜湊（Hash）

　　不固定長度的內容，經過雜湊演算法，輸出成固定長度的內容，輸出的內容無法反推回原本輸入的內容，雜湊是單向的，相同輸入經過相同演算法，必定得到相同輸出。

　　不同輸入經過相同演算法，也可能得到相同輸出，機率非常低，這種情況稱為碰撞（Collision）。

　　無法用雜湊值長度來完全斷定使用哪種雜湊演算法，兩個輸入的內容即便只差一個字，雜湊演算法產生的兩個輸出內容卻會差非常多，可以明顯區別。



加密和雜湊的差異

　　兩者最大的差別在於：「加密可逆，雜湊不可逆。」加密可以透過解密得到原文，雜湊無法逆向解出原始輸入。

　　一個安全資料庫應該儲存的是經過雜湊的密碼，而不是使用者輸入的明碼，萬一資料庫不慎遭到攻擊，駭客拿到的會是雜湊值，無法反推得到原始值，密碼只有使用者知道。



　　而為甚麼密碼需要經過雜湊才存入資料庫的原因，是因為如果使用明文存密碼，被駭客盜取的話，不需要經過任何解密即可知道使用者密碼，是非常危險的方式，另一方面也是尊重使用者，因為正常情況下只有使用者知道自己的密碼。

## `include`、`require`、`include_once`、`require_once` 的差別

　　1.include 函數：會將指定的文件讀入並且執行裡面的程序；被導入的檔案中的程序代碼都會被執行，而且這些程序在執行的時候會擁有和源文件中呼叫到 include() 函數的位置相同的變量範圍（variable scope）。你可以導入同一個服務器中的靜態檔案，甚至可以通過合併使用 include() 與 fopen() 函數來導入其它服務器上面的檔案。

　　2.require 函數：會將目標文件的內容讀入，並且把自己本身代換成這些讀入的內容；這個讀入並且代換的動作是在 PHP 引擎編譯你的程序代碼的時候發生的，而不是發生在 PHP 引擎開始執行編譯好的程序代碼的時候。

　　3.include_once 函數：在腳本執行期間包含並運行指定文件。此行為和 include 語句類似，唯一區別是如果該文件中已經被包含過，則不會再次包含。如同此語句名字暗示的那樣，只會包含一次，（這項功能有時候是很重要的，比方說要導入的檔案裡面宣告了一些你自行定義好的函數，那麼如果在同一個程序重複導入這個檔案，在第二次導入的時候便會發生錯誤訊息，因為 PHP 不允許相同名稱的函數被重複宣告第二次）。

　　4.require_once 函數：和 require 語句完全相同，唯一區別是 PHP 會檢查該文件是否已經被包含過，如果是則不會再次包含。



**include與require的區別**

　　include 與 require 除了在處理引入文件的方式不同外，最大的區別就是：include 在引入不存文件時產生一個警告且腳本還會繼續執行，而 require 則會導致一個致命性錯誤且腳本停止執行。

　　include() 與 require() 的功能相同，但在用法上卻有一些不同，include() 是有條件包含函數，而 require() 則是無條件包含函數。

　　include_once （require_once）語句在腳本執行期間包含並運行指定文件。此行為和 include （require）語句類似，區別是如果該文件中的代碼已經被包含了，則不會再次包含，只會包含一次。include_once（require_once）需要查詢一遍已加載的文件列表, 確認是否存在, 然後再加載。



**include（require）與 include_once（require_once）的抉擇問題**

　　通常：include_once 和 require_once 會有性能上的下降，因為他需要判斷之前是否包含過。一般情況下，也不太需要去考慮，除非這已經影響到你程序的性能了。

　　require通常使用方法，這個函數通常放在 PHP 程序的最前面，PHP 程序在執行前，就會先讀入 require 所指定引入的文件，使它變成 PHP 程序網頁的一部份。常用的函數，亦可以這個方法將它引入網頁中。

　　include 通常使用方法，這個函數一般是放在流程控制的處理部分中。PHP 程序網頁在讀到 include 的文件時，才將它讀進來。這種方式，可以把程序執行時的流程簡單化。

　　require() 通常來導入靜態的內容，而 include() 則適合用來導入動態的程序代碼。

原文網址：https://kknews.cc/code/5rxmlb6.html

## 請說明 SQL Injection 的攻擊原理以及防範方法

　　在這種攻擊方式中，攻擊者會將一些惡意資料庫查詢語法，輸入到開發者使用的程式碼中。然後透過各種方式 將該字串傳遞到如 MS SQL Server 資料庫的查詢命列中進行分析和執行。只要這個惡意字元或語法符合 SQL 查詢語法的規則，在應用系統的編譯與執行階段時，就不會被編譯工具或執行階段工具發現。資料庫伺服器則 會直接執行被竄改過的攻擊語法，對資料庫系統或儲存的資料，造成極大的威脅。

三種常見的 SQL injection 攻擊手法：

1. Authorization Bypass（略過權限檢查）

2. Injecting SQL Sub-Statements into SQL Queries（注入 SQL 子語法）

   　　攻擊者可以在注入惡意的 SQL 的語法去改變資料庫。

3. Exploiting Stored Procedures（利用預存程序）

   　　Stored Procedures（預存程序）是將又臭又長又常用的 SQL 語法寫成一組程序並儲存起來，以供後續呼叫相同程序時不必再將完整個 SQL 語法重打一次，攻擊者亦可透過呼叫這些 Stored Procedures 進而對 DataBase 進行攻擊。

攻擊原理：

　　在輸入內容時因為使用的
$sql = sprintf("insert into comments(nickname, content) values('%s', '%s')",$nickname, $content);
當中的 insert into 是可以同時輸入多筆資料的
比如我們可以
"insert into comments(nickname, content) values('aa', ''), ('bb', 'bb')"
就會同時增加兩筆資料！
那如果駭客在留言內容時在登入 aa 時輸入的 content 為
'), ('bb', 'you are stupid 的內容的話
整個會變成 $sql = sprintf("insert into comments(nickname, content) values('aa', ''), ('bb', 'you are stupid')")
他就可以直接讓 bb 的人留言一個惡意留言



防範方法：

　　使用 prepared statement 去解決 SQL injection 問題
把原本的
$sql = sprintf("insert into comments(nickname, content) values('%s', '%s')",$nickname, $content);
改成
$sql = "insert into comments(nickname, content) values(?, ?)";
下面接
$stmt = $conn->prepare($sql);//	stmt 是 statement 簡寫
$stmt->bind_param('ss', $nickname, $content);// bind_param() 裡面第一個傳的參數是指要幾個內容, 兩個字串所以我們輸入'ss', 後面則是我們要的內容是甚麼
$result = $stmt->execute();

$result = $stmt->execute(); 跟 $result = $conn->query($sql); 差別在於他不用傳參數進去



網路找到的防範方法：

1. 使用 Regular expression 驗證過濾輸入值與參數中惡意代碼，將輸入值中的單引號置換為雙引號。
2. 限制輸入字元格式並檢查輸入長度。
3. 資料庫設定使用者帳號權限，限制某些管道使用者無法作資料庫存取。
4. 對進入資料庫的特殊字符（'”\尖括號&*;等）進行轉義處理，或編碼轉換。
5. 嚴格限制Web應用的資料庫的操作權限，給此用戶提供僅僅能夠滿足其工作的最低權限，從而最大限度的減少注入攻擊對資料庫的危害。

##  請說明 XSS 的攻擊原理以及防範方法

　　XSS 的全名是 Cross-site Scripting（跨站指令碼攻擊），是一種程式碼注入攻擊。攻擊者通過在目標網站上注入惡意指令碼，使之在使用者的瀏覽器上執行。利用這些惡意指令碼，攻擊者可獲取使用者的敏感資訊如 Cookie、SessionID 等，進而危害資料安全。

XSS 攻擊有兩大要素：

1. 攻擊者提交惡意程式碼。
2. 瀏覽器執行惡意程式碼。

攻擊原理：

　　它的應用是可以在打字的地方
使用 <script></script>
直接在那個網頁中執行程式碼
可以用來導入其他網頁, 拿取 cookie 來讓駭客做事情

<script>alert("document.cookie")</script> 
就會顯示當下使用者的 session_id 或 cookie 了

<script>location.href"https://google.com"</script>

可以導入其他網頁



防範方法：

　　修正的方式是使用 PHP 內建的 function
htmlspecialchars($str, ENT_QUOTES) 會把一些特殊字元編成其他東西
老師推薦這個在顯示的時候做，不要在資料庫以前做，不然會把編好的字元存入資料庫，之後要其他人使用資料庫時，資料會很雜亂。

## 請說明 CSRF 的攻擊原理以及防範方法

　　CSRF是一種常見的網路攻擊手法，全名是 Cross Site Request Forgery( 跨站請求偽造)，接下來我們就來介紹一下這種攻擊手法。

　　我們知道大部分的網站應用都是採用cookie或session的方式進行登入驗證，當通過登入驗證之後，網站就會給你一個通行證存在cookie或seesion中，代表之後的動作中都不需要重複驗證身分了。但CSRF的攻擊正是鑽了這個機制的漏洞來達到攻擊的目的！



實際舉例：

　　我們可以想像cookies就像是每個人身上的筆記本，當你在A銀行登入之後，A銀行在你的筆記本上蓋了個印章，有這個印章之後，接下來三個小時內你的所有動作都不需要重複驗證身分。但你在這三小時內又跑去逛了其他網頁，很不巧的就逛到了駭客B架設的惡意網頁，這個惡意網頁偷偷複製了你的cookie筆記本的印章，跑去打A銀行的轉帳API，請A銀行把你的存款匯10萬元到駭客B自己的帳戶，由於A銀行認印章不認人，所以就接受了這筆匯款請求。

所以無辜的你，只是登入了A銀行的帳戶，同時逛逛網拍、找找資料，突然間就損失了10萬塊! 這就是CSRF可怕的地方。



普遍防禦CSRF的方法有兩種：

1. 檢查referer欄位

　　這個方法很簡單，既然攻擊是來自於非銀行網站，那我就確認需求的來源就行了，而http協定中就有一個referer欄位記錄著這個請求是從哪個網站發出來的，只要不是銀行網站發出來的請求，網站這邊一律不接受!

　　依照這樣的方式，我們可以用快速且低成本的方式來防範CSRF，只是有個問題，就是駭客能否偽造這個referer欄位呢? 如果他也可以偽裝成銀行來源，那用戶就還是會被攻擊。顯然這種方法只能初步防禦CSRF，碰到進階一點的攻擊手法就會再度被破解。



2. 加入驗證token

　　CSRF的核心概念，就是銀行不知道發出請求的人是不是攻擊者，那按照這個思路，只要使用者能提出一個唯一且保密的序號，攻擊者拿不到這個序號，自然就不能偽裝成使用者，而這個序號，就是我們稱的CSRF Token，這個Token是由銀行server產生，並且加密存在session中的，其他人無法仿造，只有透過server給使用者，並在一定時間內刷新。當使用者想做任何交易的時候，銀行server就會請使用者提供CSRF Token，如果不能提供，就代表這次的請求就是攻擊者，那銀行server就不予理會。



找到的資料：https://blog.techbridge.cc/2017/02/25/csrf-introduction/

內容太多決定放網址可以之後參考如何避免 CSRF 用